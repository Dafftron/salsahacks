// Servicios de Firestore
import { 
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
  onSnapshot,
  serverTimestamp,
  setDoc,
  writeBatch
} from 'firebase/firestore';
import { db } from './config';

// Colecciones principales
const COLLECTIONS = {
  USERS: 'users',
  NOTES: 'notes',
  CATEGORIES: 'categories',
  EVENTS: 'events',
  FIGURES: 'figures',
  SCHOOL: 'school',
  INVITATIONS: 'invitations',
  VIDEOS: 'videos'
};

// ===== USUARIOS =====
export const createUserProfile = async (userId, userData) => {
  try {
    console.log('üìù Creando perfil de usuario en Firestore:', userId)
    
    // Usar setDoc con el UID como ID del documento para evitar duplicados
    await setDoc(doc(db, COLLECTIONS.USERS, userId), {
      uid: userId,
      ...userData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    
    console.log('‚úÖ Perfil de usuario creado exitosamente en Firestore')
    return { success: true, error: null };
  } catch (error) {
    console.error('‚ùå Error al crear perfil de usuario:', error)
    return { success: false, error: error.message };
  }
};

export const getUserProfile = async (userId) => {
  try {
    console.log('üîç Buscando perfil de usuario:', userId)
    
    // Usar getDoc directamente con el UID como ID del documento
    const docRef = doc(db, COLLECTIONS.USERS, userId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      const userData = { id: docSnap.id, ...docSnap.data() };
      console.log('‚úÖ Perfil de usuario encontrado:', userData)
      return { user: userData, error: null };
    }
    
    console.log('‚ùå Usuario no encontrado en Firestore')
    return { user: null, error: 'Usuario no encontrado' };
  } catch (error) {
    console.error('‚ùå Error al obtener perfil de usuario:', error)
    return { user: null, error: error.message };
  }
};

export const updateUserProfile = async (userId, updates) => {
  try {
    console.log('üìù Actualizando perfil de usuario:', userId, updates)
    
    // Usar updateDoc directamente con el UID como ID del documento
    const docRef = doc(db, COLLECTIONS.USERS, userId);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });
    
    console.log('‚úÖ Perfil de usuario actualizado exitosamente')
    return { success: true, error: null };
  } catch (error) {
    console.error('‚ùå Error al actualizar perfil de usuario:', error)
    return { success: false, error: error.message };
  }
};

// ===== NOTAS =====
export const createNote = async (noteData) => {
  try {
    const docRef = await addDoc(collection(db, COLLECTIONS.NOTES), {
      ...noteData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return { id: docRef.id, error: null };
  } catch (error) {
    return { id: null, error: error.message };
  }
};

export const getNotes = async (userId) => {
  try {
    const q = query(
      collection(db, COLLECTIONS.NOTES),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    
    const notes = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    return { notes, error: null };
  } catch (error) {
    return { notes: [], error: error.message };
  }
};

export const updateNote = async (noteId, updates) => {
  try {
    const noteRef = doc(db, COLLECTIONS.NOTES, noteId);
    await updateDoc(noteRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });
    return { success: true, error: null };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

export const deleteNote = async (noteId) => {
  try {
    await deleteDoc(doc(db, COLLECTIONS.NOTES, noteId));
    return { success: true, error: null };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// ===== CATEGOR√çAS =====
export const getCategories = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, COLLECTIONS.CATEGORIES));
    const categories = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    return { categories, error: null };
  } catch (error) {
    return { categories: [], error: error.message };
  }
};

// ===== EVENTOS =====
export const createEvent = async (eventData) => {
  try {
    const docRef = await addDoc(collection(db, COLLECTIONS.EVENTS), {
      ...eventData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return { id: docRef.id, error: null };
  } catch (error) {
    return { id: null, error: error.message };
  }
};

export const getEvents = async () => {
  try {
    const q = query(
      collection(db, COLLECTIONS.EVENTS),
      orderBy('date', 'asc')
    );
    const querySnapshot = await getDocs(q);
    
    const events = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    return { events, error: null };
  } catch (error) {
    return { events: [], error: error.message };
  }
};

// ===== FIGURAS =====
export const createFigure = async (figureData) => {
  try {
    const docRef = await addDoc(collection(db, COLLECTIONS.FIGURES), {
      ...figureData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return { id: docRef.id, error: null };
  } catch (error) {
    return { id: null, error: error.message };
  }
};

export const getFigures = async () => {
  try {
    const querySnapshot = await getDocs(collection(db, COLLECTIONS.FIGURES));
    const figures = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    return { figures, error: null };
  } catch (error) {
    return { figures: [], error: error.message };
  }
};

// ===== ESCUELA =====
export const createSchoolContent = async (contentData) => {
  try {
    const docRef = await addDoc(collection(db, COLLECTIONS.SCHOOL), {
      ...contentData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return { id: docRef.id, error: null };
  } catch (error) {
    return { id: null, error: error.message };
  }
};

export const getSchoolContent = async () => {
  try {
    const q = query(
      collection(db, COLLECTIONS.SCHOOL),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    
    const content = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    
    return { content, error: null };
  } catch (error) {
    return { content: [], error: error.message };
  }
};

// ===== LISTENERS EN TIEMPO REAL =====
export const subscribeToNotes = (userId, callback) => {
  const q = query(
    collection(db, COLLECTIONS.NOTES),
    where('userId', '==', userId),
    orderBy('createdAt', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const notes = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    callback(notes);
  });
};

export const subscribeToEvents = (callback) => {
  const q = query(
    collection(db, COLLECTIONS.EVENTS),
    orderBy('date', 'asc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const events = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    callback(events);
  });
}; 

// Funci√≥n para crear una invitaci√≥n
export const createInvitation = async (invitationData) => {
  try {
    // Generar c√≥digo √∫nico de invitaci√≥n
    const invitationCode = generateInvitationCode()
    
    // Calcular fecha de expiraci√≥n
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + invitationData.expiresInDays)
    
    const invitation = {
      code: invitationCode,
      email: invitationData.email,
      displayName: invitationData.displayName,
      username: invitationData.username,
      role: invitationData.role,
      createdBy: invitationData.createdBy,
      createdAt: serverTimestamp(),
      expiresAt: expiresAt,
      status: 'pending', // pending, used, expired
      usedAt: null,
      usedBy: null
    }
    
    // Guardar en Firestore
    await setDoc(doc(db, 'invitations', invitationCode), invitation)
    
    return { 
      success: true, 
      invitationCode: invitationCode,
      invitation: invitation 
    }
  } catch (error) {
    console.error('Error creating invitation:', error)
    return { success: false, error: error.message }
  }
}

// Funci√≥n para validar una invitaci√≥n
export const validateInvitation = async (invitationCode) => {
  try {
    const invitationRef = doc(db, 'invitations', invitationCode)
    const invitationSnap = await getDoc(invitationRef)
    
    if (!invitationSnap.exists()) {
      return { success: false, error: 'Invitaci√≥n no encontrada' }
    }
    
    const invitation = invitationSnap.data()
    
    // Verificar si ya fue usada
    if (invitation.status === 'used') {
      return { success: false, error: 'Esta invitaci√≥n ya ha sido utilizada' }
    }
    
    // Verificar si ha expirado
    if (invitation.expiresAt && invitation.expiresAt.toDate() < new Date()) {
      return { success: false, error: 'Esta invitaci√≥n ha expirado' }
    }
    
    return { 
      success: true, 
      invitation: invitation 
    }
  } catch (error) {
    console.error('Error validating invitation:', error)
    return { success: false, error: error.message }
  }
}

// Funci√≥n para marcar invitaci√≥n como usada
export const markInvitationAsUsed = async (invitationCode, userId) => {
  try {
    const invitationRef = doc(db, 'invitations', invitationCode)
    await updateDoc(invitationRef, {
      status: 'used',
      usedAt: serverTimestamp(),
      usedBy: userId
    })
    
    return { success: true }
  } catch (error) {
    console.error('Error marking invitation as used:', error)
    return { success: false, error: error.message }
  }
}

// Funci√≥n para obtener invitaciones de un usuario
export const getUserInvitations = async (userId) => {
  try {
    const invitationsRef = collection(db, 'invitations')
    const q = query(
      invitationsRef,
      where('createdBy', '==', userId),
      orderBy('createdAt', 'desc')
    )
    
    const querySnapshot = await getDocs(q)
    const invitations = []
    
    querySnapshot.forEach((doc) => {
      invitations.push({
        id: doc.id,
        ...doc.data()
      })
    })
    
    return { success: true, invitations }
  } catch (error) {
    console.error('Error getting user invitations:', error)
    return { success: false, error: error.message }
  }
}

// Funci√≥n para eliminar una invitaci√≥n
export const deleteInvitation = async (invitationCode) => {
  try {
    await deleteDoc(doc(db, 'invitations', invitationCode))
    return { success: true }
  } catch (error) {
    console.error('Error deleting invitation:', error)
    return { success: false, error: error.message }
  }
}

// Funci√≥n auxiliar para generar c√≥digo de invitaci√≥n √∫nico
const generateInvitationCode = () => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  let result = ''
  for (let i = 0; i < 8; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return result
}

// ===== VIDEO MANAGEMENT FUNCTIONS =====

export const createVideoDocument = async (videoData) => {
  try {
    console.log('üìπ Creando documento de video en Firestore:', videoData.title)
    const videoRef = doc(collection(db, COLLECTIONS.VIDEOS))
    await setDoc(videoRef, {
      ...videoData,
      id: videoRef.id,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    })
    console.log('‚úÖ Documento de video creado exitosamente:', videoRef.id)
    return { success: true, id: videoRef.id, error: null }
  } catch (error) {
    console.error('‚ùå Error al crear documento de video:', error)
    return { success: false, error: error.message }
  }
}

export const getVideoDocument = async (videoId) => {
  try {
    console.log('üîç Buscando video:', videoId)
    const docRef = doc(db, COLLECTIONS.VIDEOS, videoId)
    const docSnap = await getDoc(docRef)
    if (docSnap.exists()) {
      const videoData = { id: docSnap.id, ...docSnap.data() }
      console.log('‚úÖ Video encontrado:', videoData.title)
      return { video: videoData, error: null }
    }
    console.log('‚ùå Video no encontrado en Firestore')
    return { video: null, error: 'Video no encontrado' }
  } catch (error) {
    console.error('‚ùå Error al obtener video:', error)
    return { video: null, error: error.message }
  }
}

export const updateVideoDocument = async (videoId, updates) => {
  try {
    console.log('üìù Actualizando video:', videoId, updates)
    const docRef = doc(db, COLLECTIONS.VIDEOS, videoId)
    await updateDoc(docRef, {
      ...updates,
      updatedAt: serverTimestamp()
    })
    console.log('‚úÖ Video actualizado exitosamente')
    return { success: true, error: null }
  } catch (error) {
    console.error('‚ùå Error al actualizar video:', error)
    return { success: false, error: error.message }
  }
}

export const deleteVideoDocument = async (videoId) => {
  try {
    console.log('üóëÔ∏è Eliminando video:', videoId)
    await deleteDoc(doc(db, COLLECTIONS.VIDEOS, videoId))
    console.log('‚úÖ Video eliminado exitosamente')
    return { success: true, error: null }
  } catch (error) {
    console.error('‚ùå Error al eliminar video:', error)
    return { success: false, error: error.message }
  }
}

export const getVideosByCategory = async (category) => {
  try {
    console.log('üîç Buscando videos por categor√≠a:', category)
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      where('category', '==', category),
      orderBy('createdAt', 'desc')
    )
    const querySnapshot = await getDocs(q)
    const videos = []
    querySnapshot.forEach((doc) => {
      videos.push({ id: doc.id, ...doc.data() })
    })
    console.log(`‚úÖ ${videos.length} videos encontrados para categor√≠a: ${category}`)
    return { videos, error: null }
  } catch (error) {
    console.error('‚ùå Error al obtener videos por categor√≠a:', error)
    return { videos: [], error: error.message }
  }
}

export const getVideosByUser = async (userId) => {
  try {
    console.log('üîç Buscando videos del usuario:', userId)
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      where('uploadedBy', '==', userId),
      orderBy('createdAt', 'desc')
    )
    const querySnapshot = await getDocs(q)
    const videos = []
    querySnapshot.forEach((doc) => {
      videos.push({ id: doc.id, ...doc.data() })
    })
    console.log(`‚úÖ ${videos.length} videos encontrados del usuario: ${userId}`)
    return { videos, error: null }
  } catch (error) {
    console.error('‚ùå Error al obtener videos del usuario:', error)
    return { videos: [], error: error.message }
  }
}

export const checkVideoDuplicate = async (originalTitle) => {
  try {
    console.log('üîç Verificando duplicado:', originalTitle)
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      where('originalTitle', '==', originalTitle)
    )
    const querySnapshot = await getDocs(q)
    const isDuplicate = !querySnapshot.empty
    console.log(`‚úÖ Verificaci√≥n de duplicado: ${isDuplicate ? 'S√ç' : 'NO'}`)
    return { isDuplicate, error: null }
  } catch (error) {
    console.error('‚ùå Error al verificar duplicado:', error)
    return { isDuplicate: false, error: error.message }
  }
}

export const getVideos = async () => {
  try {
    console.log('üîç Obteniendo todos los videos...')
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      orderBy('uploadedAt', 'desc')
    )
    const querySnapshot = await getDocs(q)
    const videos = []
    querySnapshot.forEach((doc) => {
      videos.push({ id: doc.id, ...doc.data() })
    })
    console.log(`‚úÖ ${videos.length} videos obtenidos`)
    return videos
  } catch (error) {
    console.error('‚ùå Error al obtener videos:', error)
    return []
  }
}

// ===== SINCRONIZACI√ìN EN TIEMPO REAL =====

export const subscribeToVideos = (callback) => {
  try {
    console.log('üîÑ Iniciando suscripci√≥n en tiempo real a videos...')
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      orderBy('uploadedAt', 'desc')
    )
    
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const videos = []
      snapshot.forEach((doc) => {
        videos.push({ id: doc.id, ...doc.data() })
      })
      console.log(`üîÑ Actualizaci√≥n en tiempo real: ${videos.length} videos`)
      callback(videos)
    }, (error) => {
      console.error('‚ùå Error en suscripci√≥n de videos:', error)
    })
    
    return unsubscribe
  } catch (error) {
    console.error('‚ùå Error al iniciar suscripci√≥n de videos:', error)
    return () => {}
  }
}

export const subscribeToVideosByStyle = (style, callback) => {
  try {
    console.log(`üîÑ Iniciando suscripci√≥n en tiempo real a videos de estilo: ${style}`)
    
    // Primero intentar con la consulta optimizada (requiere √≠ndice)
    const q = query(
      collection(db, COLLECTIONS.VIDEOS),
      where('style', '==', style),
      orderBy('uploadedAt', 'desc')
    )
    
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const videos = []
      snapshot.forEach((doc) => {
        videos.push({ id: doc.id, ...doc.data() })
      })
      console.log(`üîÑ Actualizaci√≥n en tiempo real para ${style}: ${videos.length} videos`)
      callback(videos)
    }, (error) => {
      console.error(`‚ùå Error en suscripci√≥n de videos de ${style}:`, error)
      
      // Si falla por falta de √≠ndice, usar consulta simple y filtrar en cliente
      if (error.code === 'failed-precondition' || error.message.includes('index')) {
        console.log(`‚ö†Ô∏è Usando fallback para ${style} (sin √≠ndice)`)
        
        const fallbackQuery = query(
          collection(db, COLLECTIONS.VIDEOS),
          orderBy('uploadedAt', 'desc')
        )
        
        const fallbackUnsubscribe = onSnapshot(fallbackQuery, (snapshot) => {
          const allVideos = []
          snapshot.forEach((doc) => {
            allVideos.push({ id: doc.id, ...doc.data() })
          })
          
          // Filtrar por estilo en el cliente (solo por el campo style)
          const filteredVideos = allVideos.filter(video => 
            video.style === style
          )
          
          console.log(`üîÑ Fallback: ${filteredVideos.length} videos de ${style} de ${allVideos.length} total`)
          callback(filteredVideos)
        }, (fallbackError) => {
          console.error(`‚ùå Error en fallback para ${style}:`, fallbackError)
        })
        
        return fallbackUnsubscribe
      }
    })
    
    return unsubscribe
  } catch (error) {
    console.error(`‚ùå Error al iniciar suscripci√≥n de videos de ${style}:`, error)
    return () => {}
  }
}

// ===== FUNCIONES DE LIMPIEZA DE DATOS =====

export const deleteAllVideos = async () => {
  try {
    console.log('üóëÔ∏è Iniciando eliminaci√≥n de todos los videos...')
    
    // Obtener todos los videos
    const videos = await getVideos()
    console.log(`üìä Videos a eliminar: ${videos.length}`)
    
    if (videos.length === 0) {
      console.log('‚úÖ No hay videos para eliminar')
      return { success: true, deletedCount: 0, error: null }
    }
    
    // Eliminar documentos en lotes
    const batch = writeBatch(db)
    let deletedCount = 0
    
    videos.forEach((video) => {
      const videoRef = doc(db, COLLECTIONS.VIDEOS, video.id)
      batch.delete(videoRef)
      deletedCount++
    })
    
    await batch.commit()
    console.log(`‚úÖ ${deletedCount} videos eliminados de Firestore`)
    
    return { success: true, deletedCount, error: null }
  } catch (error) {
    console.error('‚ùå Error al eliminar todos los videos:', error)
    return { success: false, deletedCount: 0, error: error.message }
  }
}

export const updateVideoThumbnailPaths = async () => {
  try {
    console.log('üîß Iniciando actualizaci√≥n de rutas de thumbnails...')
    
    const videos = await getVideos()
    console.log(`üìä Videos a actualizar: ${videos.length}`)
    
    if (videos.length === 0) {
      console.log('‚úÖ No hay videos para actualizar')
      return { success: true, updatedCount: 0, error: null }
    }
    
    const batch = writeBatch(db)
    let updatedCount = 0
    
    videos.forEach((video) => {
      // Si el video no tiene thumbnailPath o es incorrecto, intentar corregirlo
      if (!video.thumbnailPath || video.thumbnailPath === 'placeholder') {
        const videoRef = doc(db, COLLECTIONS.VIDEOS, video.id)
        batch.update(videoRef, {
          thumbnailPath: null, // Establecer como null para que se maneje en la eliminaci√≥n
          updatedAt: serverTimestamp()
        })
        updatedCount++
      }
    })
    
    if (updatedCount > 0) {
      await batch.commit()
      console.log(`‚úÖ ${updatedCount} videos actualizados`)
    } else {
      console.log('‚úÖ No se requirieron actualizaciones')
    }
    
    return { success: true, updatedCount, error: null }
  } catch (error) {
    console.error('‚ùå Error al actualizar rutas de thumbnails:', error)
    return { success: false, updatedCount: 0, error: error.message }
  }
} 

// ===== FUNCIONES DE DIAGN√ìSTICO =====

export const diagnoseVideos = async () => {
  try {
    console.log('üîç Iniciando diagn√≥stico de videos...')
    
    // Obtener todos los videos sin filtros
    const allVideos = await getVideos()
    console.log(`üìä Total de videos en Firestore: ${allVideos.length}`)
    
    // Agrupar por estilo
    const videosByStyle = {}
    allVideos.forEach(video => {
      const style = video.style || 'sin-estilo'
      if (!videosByStyle[style]) {
        videosByStyle[style] = []
      }
      videosByStyle[style].push(video)
    })
    
    console.log('üìä Videos por estilo:', videosByStyle)
    
    // Verificar videos de salsa espec√≠ficamente
    const salsaVideos = allVideos.filter(video => 
      video.style === 'salsa' || 
      (video.tags && video.tags.estilo && video.tags.estilo.includes('salsa'))
    )
    
    console.log(`üìä Videos de salsa encontrados: ${salsaVideos.length}`)
    salsaVideos.forEach(video => {
      console.log(`  - ${video.title} (ID: ${video.id}, Style: ${video.style})`)
    })
    
    // Buscar espec√≠ficamente el video Fig003
    const fig003Video = allVideos.find(video => 
      video.originalTitle && video.originalTitle.includes('Fig003')
    )
    
    if (fig003Video) {
      console.log('üéØ Video Fig003 encontrado:', fig003Video)
    } else {
      console.log('‚ùå Video Fig003 NO encontrado en Firestore')
    }
    
    return {
      success: true,
      totalVideos: allVideos.length,
      videosByStyle,
      salsaVideos: salsaVideos.length,
      fig003Found: !!fig003Video,
      fig003Video,
      error: null
    }
  } catch (error) {
    console.error('‚ùå Error en diagn√≥stico de videos:', error)
    return {
      success: false,
      totalVideos: 0,
      videosByStyle: {},
      salsaVideos: 0,
      fig003Found: false,
      fig003Video: null,
      error: error.message
    }
  }
} 